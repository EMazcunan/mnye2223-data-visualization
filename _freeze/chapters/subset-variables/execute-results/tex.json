{
  "hash": "b3ceb63c884ea707127a982e7dc8d31a",
  "result": {
    "markdown": "---\n# editor:\n#     render-on-save: true\n---\n\n\n\n# Seleccionar variables {#sec-subset-variables}\n\nAl estudiar un conjunto de datos, es frecuente tener que seleccionar los datos relevantes para responder a las diferentes cuestiones planteadas. \n\n\nSi por ejemplo queremos saber cuál es el peso máximo de todos los pingüinos del estudio, seleccionaremos la variable `body_mass_g` y después calcularemos su máximo. \n\nEn esta sección aprenderás los métodos para seleccionar variables de una hoja de datos.\n\n\n## Seleccionar una variable {#sec-subset-one-variable}\n\nUtiliza la siguiente instrucción para seleccionar la variable `body_mass_g`:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nmass = penguins[\"body_mass_g\"]\n```\n:::\n\n\n::: {.callout-note}\nPara seleccionar una sola variable, usa corchetes `[]` e indica el nombre de la columna de interés.\n:::\n \n\nAhora podemos aplicar la función `max()` para obtener el peso máximo:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nmass.max()\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n6300.0\n```\n:::\n:::\n\n\nVemos que el pingüino más pesado del estudio pesa $6$ kilos y $300$ gramos.\n\n\n<!-- ```{python}\nindex = mass.argmax()\npenguins.loc[index]\n``` -->\n\nPodemos realizar las dos operaciones anteriores, seleccionar la variable `body_mass_g`, y calcular su máximo  con una sola instrucción:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\npenguins[\"body_mass_g\"].max()\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n6300.0\n```\n:::\n:::\n\n\nObtenemos el mismo resultado de antes.\n\n\n::: {#exr-subset-variable-1}\nCalcula  el peso medio  de todos los pingüinos (función `mean()`).\n:::\n\n::: {#exr-subset-variable-2}\nCalcula el valor mínimo para la longitud de las alas de todos los pingüinos (función `min()`).\n:::\n\n\n## Seleccionar una lista de variables {#sec-subset-several-variables}\n\nPara seleccionar las dos variables relativas a las dimensiones del pico, `bill_length_mm` y  `bill_depth_mm`, ejecuta la siguiente instrucción:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nbill = penguins[[\"bill_length_mm\", \"bill_depth_mm\"]]\n```\n:::\n\n\n::: {.callout-note}\nPara seleccionar una lista de variables, usa corchetes `[]` adicionales para crear la lista con los nombres de las columnas de interés (los corchetes exteriores indican que se van a seleccionar datos y los interiores crean la lista).\n:::\n\nAhora podemos calcular la media para ambas variables con \n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nbill.mean()\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=tex}\n\\begin{tabular}{lr}\n\\toprule\n{} &         0 \\\\\n\\midrule\nbill\\_length\\_mm &  43.92193 \\\\\nbill\\_depth\\_mm  &  17.15117 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nVemos que los picos de los pingüinos tiene una longitud media de  $43.92$ milímetros y una anchura media de $17.15$ milímetros.\n\n::: {#exr-subset-variables-3}\nCalcula el número de observaciones no nulas (función `count()`) para las variables `species` y `body_mass_g` con una sola línea de código.\n:::\n\n<!-- \n## `DataFrame` vs `Series` \n\nEjecutando \n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ntype(bill)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\npandas.core.frame.DataFrame\n```\n:::\n:::\n\n\nvemos que el objeto `bill` que hemos creado antes al extraer las dos variables sobre las dimensiones del pico es de tipo `DataFrame`, igual que la hoja de datos original `penguins`.\n\n\nPero ejecutando \n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ntype(mass)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\npandas.core.series.Series\n```\n:::\n:::\n\n\nvemos que el objeto `mass` que hemos creado antes al extraer la variable `body_mass_g` es de un nuevo tipo, llamado `Series`. \n\n`Series` es el tipo de datos que usa `pandas` para almacenar vectores unidimensionales, representando un conjunto de observaciones de una variable. \n\nPodemos usar el método `head()` para ver los cinco primeros valores de la variable:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nmass.head(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```{=tex}\n\\begin{tabular}{lr}\n\\toprule\n{} &  body\\_mass\\_g \\\\\n\\midrule\n0 &       3750.0 \\\\\n1 &       3800.0 \\\\\n2 &       3250.0 \\\\\n3 &          NaN \\\\\n4 &       3450.0 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nAprecia que `mass` tiene el mismo índice que la hoja de datos `penguins`:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nmass.index\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nRangeIndex(start=0, stop=344, step=1)\n```\n:::\n:::\n\n\nPodemos ver una hoja de datos (`DataFrame`) como un conjunto de variables (`Series`), dispuestas en columnas,  que comparten un índice común.\n\n::: {#exr-series}\nAverigua si los siguientes objetos son de tipo `Series` o `DataFrame`:\n\n1. `penguins[\"flipper_length_mm\"]`\n\n2. `penguins[[\"flipper_length_mm\"]]`\n:::\n\nGeneralmente al aplicar un método propio de la clase `Series` a un objeto de clase `DataFrame`, se obtiene el mismo resultado que si se aplicara el método a cada una de las variables de la hoja de datos. Como hicimos antes al calcular simultáneamente la media de las dos variables en la hoja de datos `bill` con `bill.mean()`. \n\n\nPero hay métodos propios de `Series` que no pueden aplicarse a `DataFrame`, métodos propios de `DataFrame` que no pueden aplicarse a `Series`, y métodos comunes a `Series` y `DataFrame` pero que requieren diferentes argumentos en cada caso. Por ejemplo, el método `Series.sort_values()` ordena los valores de una variable de mayor a menor. Puedes comprobarlo con\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nmass.sort_values().head(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=tex}\n\\begin{tabular}{lr}\n\\toprule\n{} &  body\\_mass\\_g \\\\\n\\midrule\n190 &       2700.0 \\\\\n64  &       2850.0 \\\\\n58  &       2850.0 \\\\\n116 &       2900.0 \\\\\n98  &       2900.0 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nSin embargo  el método `DataFrame.sort_values()` no puede aplicarse sin argumentos. \n\n::: {#exr-sort_values}\nVerifica que al ejecutar `bill.sort_values()` se obtiene un error e intenta interpretarlo y corregirlo. \n:::\n\n\n -->\n\n",
    "supporting": [
      "subset-variables_files"
    ],
    "filters": []
  }
}