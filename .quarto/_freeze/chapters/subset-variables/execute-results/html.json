{
  "hash": "71bd8a9ce440c8f05a972f98ec898c5d",
  "result": {
    "markdown": "---\ntitle: Seleccionar variables\n# editor:\n#     render-on-save: true\n---\n\n\n\nAl estudiar un conjunto de datos, es frecuente tener que seleccionar los datos relevantes para responder a las diferentes cuestiones planteadas. \n\n\nSi por ejemplo queremos saber cuál es el peso máximo de todos los pingüinos del estudio, seleccionaremos la variable `body_mass_g` y después calcularemos su máximo. \n\nEn esta sección aprenderás los métodos para seleccionar variables de una hoja de datos.\n\n\n## Seleccionar una variable\n\nUtiliza la siguiente instrucción para seleccionar la variable `body_mass_g`:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nmass = penguins[\"body_mass_g\"]\n```\n:::\n\n\n::: {.callout-note}\nPara seleccionar una sola variable, usa corchetes `[]` e indica el nombre de la columna de interés.\n:::\n \n\nAhora podemos aplicar la función `max()` para obtener el peso máximo:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nmass.max()\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n6300.0\n```\n:::\n:::\n\n\nVemos que el pingüino más pesado del estudio pesa $6$ kilos y $300$ gramos.\n\n\n<!-- ```{python}\nindex = mass.argmax()\npenguins.loc[index]\n``` -->\n\nPodemos realizar las dos operaciones, seleccionar la variable `body_mass_g`, y calcular su máximo  con una sola instrucción:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\npenguins[\"body_mass_g\"].max()\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n6300.0\n```\n:::\n:::\n\n\n::: {#exr-subset-variable-1}\nCalcula  el peso medio  de todos los pingüinos (función `mean()`).\n:::\n\n::: {#exr-subset-variable-2}\nCalcula el valor mínimo para la longitud de las alas de todos los pingüinos (función `min()`).\n:::\n\n\n## Seleccionar una lista de variables\n\nPara seleccionar las dos variables relativas a las dimensiones del pico, `bill_length_mm` y  `bill_depth_mm`, ejecuta la siguiente instrucción:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nbill = penguins[[\"bill_length_mm\", \"bill_depth_mm\"]]\n```\n:::\n\n\n::: {.callout-note}\nPara seleccionar una lista de variables, usa corchetes `[]` adicionales para crear la lista con los nombres de las columnas de interés (los corchetes exteriores indican que se van a seleccionar datos y los interiores crean la lista).\n:::\n\nAhora podemos calcular la media para ambas variables con \n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nbill.mean()\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\nbill_length_mm    43.92193\nbill_depth_mm     17.15117\ndtype: float64\n```\n:::\n:::\n\n\n::: {#exr-subset-variables-3}\nCalcula el número de observaciones no nulas (función `count()`) para las variables `species` y `body_mass_g` con una sola línea de código.\n:::\n\n\n## `DataFrame` vs `Series` \n\nEjecutando \n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ntype(bill)\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\npandas.core.frame.DataFrame\n```\n:::\n:::\n\n\nvemos que el objeto `bill` que hemos creado antes al extraer las dos variables sobre las dimensiones del pico es de tipo `DataFrame`, igual que la hoja de datos original `penguins`.\n\n\nPero ejecutando \n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ntype(mass)\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\npandas.core.series.Series\n```\n:::\n:::\n\n\nvemos que el objeto `mass` que hemos creado antes al extraer la variable `body_mass_g` es de un nuevo tipo, llamado `Series`. \n\n`Series` es el tipo de datos que usa `pandas` para almacenar vectores unidimensionales, representando un conjunto de observaciones de una variable. \n\nPodemos usar el método `head()` para ver los cinco primeros valores de la variable:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nmass.head(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n0    3750.0\n1    3800.0\n2    3250.0\n3       NaN\n4    3450.0\nName: body_mass_g, dtype: float64\n```\n:::\n:::\n\n\nAprecia que `mass` tiene el mismo índice que la hoja de datos `penguins`:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nmass.index\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\nRangeIndex(start=0, stop=344, step=1)\n```\n:::\n:::\n\n\nPodemos ver una hoja de datos (`DataFrame`) como un conjunto de variables (`Series`), dispuestas en columnas,  que comparten un índice común.\n\n::: {#exr-series}\nAverigua si los siguientes objetos son de tipo `Series` o `DataFrame`:\n\n1. `penguins[\"flipper_length_mm\"]`\n\n2. `penguins[[\"flipper_length_mm\"]]`\n:::\n\nGeneralmente al aplicar un método propio de la clase `Series` a un objeto de clase `DataFrame`, se obtiene el mismo resultado que si se aplicara el método a cada una de las variables de la hoja de datos. Como hicimos antes al calcular simultáneamente la media de las dos variables en la hoja de datos `bill` con `bill.mean()`. \n\n\nPero hay métodos propios de `Series` que no pueden aplicarse a `DataFrame`, métodos propios de `DataFrame` que no pueden aplicarse a `Series`, y métodos comunes a `Series` y `DataFrame` pero que requieren diferentes argumentos en cada caso. Por ejemplo, el método `Series.sort_values()` ordena los valores de una variable de mayor a menor. Puedes comprobarlo con\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nmass.sort_values().head(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n190    2700.0\n64     2850.0\n58     2850.0\n116    2900.0\n98     2900.0\nName: body_mass_g, dtype: float64\n```\n:::\n:::\n\n\nSin embargo  el método `DataFrame.sort_values()` no puede aplicarse sin argumentos. \n\n::: {#exr-sort_values}\nVerifica que al ejecutar `bill.sort_values()` se obtiene un error e intenta interpretarlo y corregirlo. \n:::\n\n",
    "supporting": [
      "subset-variables_files"
    ],
    "filters": [],
    "includes": {}
  }
}